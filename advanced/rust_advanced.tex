\documentclass[11pt]{beamer}
\usetheme{Madrid}
\usecolortheme{default}
\usepackage{listings}
\usepackage{xcolor}

% Rust syntax highlighting
\lstdefinestyle{rust}{
  language=C++,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  morekeywords={fn, let, mut, impl, trait, struct, enum, match, if, else, loop, while, for, in, return, pub, use, mod, crate, self, super, const, static, async, await, move, ref, dyn, where, type, unsafe, extern}
}

\lstset{style=rust}

\title{Advanced Rust Programming}
\subtitle{Expert-Level Techniques and Internals}
\author{Rust Learning Series - Advanced Track}
\date{\today}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Prerequisites}
  \textbf{This presentation assumes mastery of:}
  \begin{itemize}
    \item All intermediate topics (traits, lifetimes, macros)
    \item Unsafe Rust and FFI
    \item Advanced async programming
    \item Performance optimization techniques
    \item Lock-free concurrency patterns
  \end{itemize}

  \vspace{0.5cm}
  \textbf{What we'll cover:}
  \begin{itemize}
    \item Compiler internals and MIR
    \item Advanced proc macro techniques
    \item Custom allocators and memory management
    \item No-std and embedded systems
    \item WebAssembly deep dive
    \item Building language tooling
  \end{itemize}
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

% ============================================
% PART 1: COMPILER INTERNALS
% ============================================
\section{Compiler Internals and MIR}

\begin{frame}[fragile]{Rust Compilation Pipeline}
  \begin{block}{Compilation Stages}
    \begin{enumerate}
      \item Lexing and Parsing (AST)
      \item Macro Expansion
      \item HIR (High-level IR)
      \item Type Checking and Inference
      \item MIR (Mid-level IR)
      \item Borrow Checking
      \item Optimization
      \item LLVM IR
      \item Machine Code
    \end{enumerate}
  \end{block}

  \begin{lstlisting}
// View MIR for a function
#[rustc_dump_mir(before = "all", after = "all")]
fn example(x: i32) -> i32 {
    x * 2 + 1
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Working with MIR}
  \begin{lstlisting}
// Simplified MIR representation
fn example(_1: i32) -> i32 {
    let mut _0: i32;
    let mut _2: i32;
    let mut _3: i32;

    bb0: {
        _2 = _1;
        _3 = const 2_i32;
        _2 = Mul(move _2, move _3);
        _3 = const 1_i32;
        _0 = Add(move _2, move _3);
        return;
    }
}
  \end{lstlisting}

  \textbf{MIR is used for:} Borrow checking, optimization, const evaluation
\end{frame}

\begin{frame}[fragile]{Compiler Plugins and Lints}
  \begin{lstlisting}
#![feature(rustc_private)]
extern crate rustc_lint;
extern crate rustc_middle;

use rustc_lint::{LateContext, LateLintPass, LintContext};

declare_lint! {
    pub CUSTOM_LINT,
    Warn,
    "description of custom lint"
}

impl<'tcx> LateLintPass<'tcx> for CustomLint {
    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr) {
        // Custom lint logic
    }
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 2: ADVANCED PROC MACROS
% ============================================
\section{Advanced Procedural Macros}

\begin{frame}[fragile]{Complex Derive Macros}
  \begin{lstlisting}
#[proc_macro_derive(Builder, attributes(builder))]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let name = &input.ident;
    let builder_name = format_ident!("{}Builder", name);

    let fields = match &input.data {
        Data::Struct(data) => &data.fields,
        _ => panic!("Builder only works on structs"),
    };

    // Generate builder methods
    let methods = fields.iter().map(|f| {
        let field_name = &f.ident;
        let field_type = &f.ty;
        quote! {
            pub fn #field_name(mut self, value: #field_type)
                -> Self
            {
                self.#field_name = Some(value);
                self
            }
        }
    });

    // ... more complex logic
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Parsing Complex Syntax}
  \begin{lstlisting}
use syn::{parse::Parse, Token};

struct MyMacroInput {
    name: Ident,
    _arrow: Token![=>],
    value: Expr,
}

impl Parse for MyMacroInput {
    fn parse(input: ParseStream) -> Result<Self> {
        Ok(MyMacroInput {
            name: input.parse()?,
            _arrow: input.parse()?,
            value: input.parse()?,
        })
    }
}

#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let parsed = parse_macro_input!(input as MyMacroInput);
    // Use parsed.name and parsed.value
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Hygiene and Spans}
  \begin{lstlisting}
use proc_macro::Span;
use quote::quote_spanned;

fn generate_with_span(span: Span) -> TokenStream {
    quote_spanned! {span=>
        compile_error!("Error at original location");
    }.into()
}

// Preserve spans for better error messages
let tokens = quote_spanned! {field.span()=>
    self.#field_name = value;
};
  \end{lstlisting}

  \begin{alertblock}{Hygiene}
    Macro-generated identifiers don't interfere with user code
  \end{alertblock}
\end{frame}

% ============================================
% PART 3: CUSTOM ALLOCATORS
% ============================================
\section{Custom Allocators}

\begin{frame}[fragile]{The Allocator Trait}
  \begin{lstlisting}
use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        println!("Allocating {} bytes", layout.size());
        System.alloc(layout)
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        println!("Deallocating {} bytes", layout.size());
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static ALLOCATOR: MyAllocator = MyAllocator;
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Arena Allocators}
  \begin{lstlisting}
struct Arena {
    buf: Vec<u8>,
    offset: usize,
}

impl Arena {
    fn alloc<T>(&mut self, value: T) -> &mut T {
        let layout = Layout::new::<T>();
        let offset = self.offset;
        self.offset += layout.size();

        unsafe {
            let ptr = self.buf.as_mut_ptr()
                .add(offset) as *mut T;
            ptr.write(value);
            &mut *ptr
        }
    }

    fn reset(&mut self) {
        self.offset = 0;
        // No individual drops - bulk deallocation
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Per-Collection Allocators}
  \begin{lstlisting}
#![feature(allocator_api)]

use std::alloc::Allocator;

// Custom allocator for specific use case
struct BumpAllocator { /* ... */ }

unsafe impl Allocator for BumpAllocator {
    fn allocate(&self, layout: Layout)
        -> Result<NonNull<[u8]>, AllocError>
    {
        // Bump allocation logic
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
        // No-op for bump allocator
    }
}

// Use with collections
let vec: Vec<i32, BumpAllocator> =
    Vec::new_in(bump_allocator);
  \end{lstlisting}
\end{frame}

% ============================================
% PART 4: NO-STD AND EMBEDDED
% ============================================
\section{No-Std and Embedded Systems}

\begin{frame}[fragile]{No-Std Fundamentals}
  \begin{lstlisting}
#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[no_mangle]
pub extern "C" fn _start() -> ! {
    // Entry point for bare metal
    loop {}
}

// Use core instead of std
use core::ptr;
use core::mem;
  \end{lstlisting}

  \textbf{No-std environment:} No heap, no OS, minimal runtime
\end{frame}

\begin{frame}[fragile]{Embedded HAL (Hardware Abstraction Layer)}
  \begin{lstlisting}
use embedded_hal::digital::v2::OutputPin;

struct Led<P: OutputPin> {
    pin: P,
}

impl<P: OutputPin> Led<P> {
    fn on(&mut self) -> Result<(), P::Error> {
        self.pin.set_high()
    }

    fn off(&mut self) -> Result<(), P::Error> {
        self.pin.set_low()
    }
}

// Works with any GPIO implementation
let mut led = Led { pin: gpio_pin };
led.on().unwrap();
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Volatile Memory Access}
  \begin{lstlisting}
use core::ptr::{read_volatile, write_volatile};

// Memory-mapped IO
const GPIO_BASE: usize = 0x4000_0000;

#[repr(C)]
struct GpioRegisters {
    data: u32,
    direction: u32,
    interrupt: u32,
}

fn set_gpio(bit: u8) {
    unsafe {
        let gpio = GPIO_BASE as *mut GpioRegisters;
        let mut data = read_volatile(&(*gpio).data);
        data |= 1 << bit;
        write_volatile(&mut (*gpio).data, data);
    }
}
  \end{lstlisting}

  \textbf{Volatile:} Prevents compiler optimizations on hardware registers
\end{frame}

\begin{frame}[fragile]{Interrupt Handling}
  \begin{lstlisting}
use cortex_m_rt::interrupt;

#[interrupt]
fn TIM2() {
    // Timer 2 interrupt handler
    static mut COUNT: u32 = 0;

    unsafe {
        *COUNT += 1;
        // Clear interrupt flag
        (*TIM2::ptr()).sr.modify(|_, w| w.uif().clear_bit());
    }
}

// Configure interrupt
unsafe {
    cortex_m::peripheral::NVIC::unmask(Interrupt::TIM2);
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 5: WEBASSEMBLY
% ============================================
\section{WebAssembly Deep Dive}

\begin{frame}[fragile]{Wasm Bindgen}
  \begin{lstlisting}
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

#[wasm_bindgen]
pub fn greet(name: &str) {
    log(&format!("Hello, {}!", name));
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{JavaScript Interop}
  \begin{lstlisting}
use wasm_bindgen::JsCast;
use web_sys::{Document, Element, HtmlElement};

#[wasm_bindgen(start)]
pub fn main() -> Result<(), JsValue> {
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();

    let body = document.body().unwrap();
    let div = document.create_element("div")?;
    div.set_inner_html("Hello from Rust!");

    body.append_child(&div)?;
    Ok(())
}
  \end{lstlisting}

  \textbf{web-sys:} Auto-generated bindings for Web APIs
\end{frame}

\begin{frame}[fragile]{Optimizing Wasm Size}
  \begin{lstlisting}
# Cargo.toml
[profile.release]
opt-level = "z"          # Optimize for size
lto = true               # Link-time optimization
codegen-units = 1        # Better optimization
panic = "abort"          # Smaller binary
strip = true             # Strip symbols

# Additional tools
# wasm-opt for further optimization
# wasm-snip to remove unused code
  \end{lstlisting}

  \begin{block}{Size Reduction Techniques}
    \begin{itemize}
      \item Avoid formatting macros in release
      \item Use \texttt{wee\_alloc} instead of default allocator
      \item Tree-shake with \texttt{wasm-gc}
    \end{itemize}
  \end{block}
\end{frame}

% ============================================
% PART 6: ASYNC RUNTIME INTERNALS
% ============================================
\section{Async Runtime Internals}

\begin{frame}[fragile]{Building a Simple Executor}
  \begin{lstlisting}
use std::future::Future;
use std::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};

struct SimpleExecutor {
    tasks: Vec<Pin<Box<dyn Future<Output = ()>>>>,
}

impl SimpleExecutor {
    fn run(&mut self) {
        while !self.tasks.is_empty() {
            self.tasks.retain_mut(|task| {
                let waker = create_waker();
                let mut cx = Context::from_waker(&waker);

                match task.as_mut().poll(&mut cx) {
                    Poll::Ready(()) => false,  // Remove
                    Poll::Pending => true,     // Keep
                }
            });
        }
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Waker Implementation}
  \begin{lstlisting}
fn create_waker() -> Waker {
    unsafe fn clone(ptr: *const ()) -> RawWaker {
        RawWaker::new(ptr, &VTABLE)
    }

    unsafe fn wake(_: *const ()) {
        // Wake the task
    }

    unsafe fn wake_by_ref(_: *const ()) {
        // Wake without consuming
    }

    unsafe fn drop(_: *const ()) {}

    static VTABLE: RawWakerVTable = RawWakerVTable::new(
        clone, wake, wake_by_ref, drop
    );

    let raw = RawWaker::new(std::ptr::null(), &VTABLE);
    unsafe { Waker::from_raw(raw) }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Reactor Pattern}
  \begin{lstlisting}
use mio::{Events, Interest, Poll, Token};

struct Reactor {
    poll: Poll,
    events: Events,
    handlers: HashMap<Token, Box<dyn FnMut()>>,
}

impl Reactor {
    fn register<S: Source>(&mut self, source: &mut S,
                           handler: impl FnMut() + 'static)
    {
        let token = Token(self.handlers.len());
        self.poll.registry()
            .register(source, token, Interest::READABLE)
            .unwrap();
        self.handlers.insert(token, Box::new(handler));
    }

    fn run(&mut self) {
        loop {
            self.poll.poll(&mut self.events, None).unwrap();
            for event in &self.events {
                if let Some(handler) = self.handlers.get_mut(&event.token()) {
                    handler();
                }
            }
        }
    }
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 7: LOCK-FREE ALGORITHMS
% ============================================
\section{Advanced Lock-Free Algorithms}

\begin{frame}[fragile]{ABA Problem and Solutions}
  \begin{lstlisting}
use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};

// Simple (unsafe) stack - has ABA problem
struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

struct Stack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> Stack<T> {
    fn push(&self, data: T) {
        let node = Box::into_raw(Box::new(Node {
            data,
            next: std::ptr::null_mut(),
        }));

        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*node).next = head; }

            if self.head.compare_exchange(
                head, node,
                Ordering::Release, Ordering::Acquire
            ).is_ok() {
                break;
            }
        }
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Tagged Pointers for ABA Prevention}
  \begin{lstlisting}
// Pack counter with pointer
struct Tagged<T> {
    ptr: usize,  // Bottom bits: counter, top bits: pointer
}

impl<T> Tagged<T> {
    fn new(ptr: *mut T, tag: usize) -> Self {
        let addr = ptr as usize;
        Tagged { ptr: addr | (tag & 0xFFFF) }
    }

    fn get_ptr(&self) -> *mut T {
        (self.ptr & !0xFFFF) as *mut T
    }

    fn get_tag(&self) -> usize {
        self.ptr & 0xFFFF
    }
}

// Use AtomicUsize for tagged pointer
struct AbaFreeSta ck<T> {
    head: AtomicUsize,
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Epoch-Based Reclamation}
  \begin{lstlisting}
use crossbeam_epoch::{self as epoch, Atomic, Owned};

struct Node<T> {
    data: T,
    next: Atomic<Node<T>>,
}

struct Stack<T> {
    head: Atomic<Node<T>>,
}

impl<T> Stack<T> {
    fn push(&self, data: T) {
        let node = Owned::new(Node {
            data,
            next: Atomic::null(),
        });

        let guard = epoch::pin();
        loop {
            let head = self.head.load(Ordering::Acquire, &guard);
            node.next.store(head, Ordering::Relaxed);

            if self.head.compare_exchange(
                head, node,
                Ordering::Release, Ordering::Acquire, &guard
            ).is_ok() {
                break;
            }
        }
    }
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 8: BUILDING LANGUAGE TOOLING
% ============================================
\section{Building Language Tooling}

\begin{frame}[fragile]{Using rust-analyzer APIs}
  \begin{lstlisting}
use ra_ap_syntax::{ast, AstNode, SyntaxKind};
use ra_ap_ide::{Analysis, AnalysisHost, FileId};

fn analyze_code(source: &str) -> Vec<String> {
    let parse = ast::SourceFile::parse(source);
    let root = parse.tree();

    let mut functions = Vec::new();

    for node in root.syntax().descendants() {
        if let Some(func) = ast::Fn::cast(node) {
            if let Some(name) = func.name() {
                functions.push(name.to_string());
            }
        }
    }

    functions
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Custom Cargo Subcommands}
  \begin{lstlisting}
// cargo-mycmd/src/main.rs
use clap::Parser;

#[derive(Parser)]
#[command(name = "cargo")]
#[command(bin_name = "cargo")]
enum Cargo {
    Mycmd(Args),
}

#[derive(Parser)]
struct Args {
    #[arg(long)]
    verbose: bool,
}

fn main() {
    let Cargo::Mycmd(args) = Cargo::parse();

    // Access cargo metadata
    let metadata = cargo_metadata::MetadataCommand::new()
        .exec()
        .unwrap();

    // Implement custom logic
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{LSP Server Implementation}
  \begin{lstlisting}
use tower_lsp::{LspService, Server};
use tower_lsp::lsp_types::*;

struct Backend;

#[tower_lsp::async_trait]
impl LanguageServer for Backend {
    async fn initialize(&self, _: InitializeParams)
        -> Result<InitializeResult>
    {
        Ok(InitializeResult {
            capabilities: ServerCapabilities {
                text_document_sync: Some(
                    TextDocumentSyncCapability::Kind(
                        TextDocumentSyncKind::FULL
                    )
                ),
                completion_provider: Some(CompletionOptions::default()),
                ..Default::default()
            },
            ..Default::default()
        })
    }

    async fn completion(&self, _: CompletionParams)
        -> Result<Option<CompletionResponse>>
    {
        // Provide completions
    }
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 9: PERFORMANCE PROFILING
% ============================================
\section{Performance Profiling and Optimization}

\begin{frame}[fragile]{Benchmarking with Criterion}
  \begin{lstlisting}
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
        b.iter(|| fibonacci(black_box(20)))
    });

    c.bench_function("fib_iterative 20", |b| {
        b.iter(|| fib_iterative(black_box(20)))
    });
}

criterion_group!(benches, fibonacci_benchmark);
criterion_main!(benches);
  \end{lstlisting}

  \begin{block}{Criterion Features}
    \begin{itemize}
      \item Statistical analysis
      \item HTML reports with plots
      \item Comparison across runs
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{CPU Profiling}
  \begin{lstlisting}
# Using perf on Linux
$ cargo build --release
$ perf record --call-graph=dwarf ./target/release/myapp
$ perf report

# Using flamegraph
$ cargo install flamegraph
$ cargo flamegraph

# Using samply (modern alternative)
$ cargo install samply
$ samply record ./target/release/myapp
  \end{lstlisting}

  \textbf{Profile-guided optimization (PGO):}
  \begin{lstlisting}
# 1. Build with instrumentation
RUSTFLAGS="-Cprofile-generate=/tmp/pgo" cargo build --release

# 2. Run typical workloads
./target/release/myapp < typical_input.txt

# 3. Rebuild with profile data
RUSTFLAGS="-Cprofile-use=/tmp/pgo" cargo build --release
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Memory Profiling}
  \begin{lstlisting}
// Using dhat for heap profiling
#[global_allocator]
static ALLOC: dhat::Alloc = dhat::Alloc;

fn main() {
    let _profiler = dhat::Profiler::new_heap();

    // Your code here
    let v: Vec<u64> = (0..1_000_000).collect();

    // Profiler drops, generating report
}

// Using valgrind massif
$ valgrind --tool=massif ./target/release/myapp
$ ms_print massif.out.12345
  \end{lstlisting}
\end{frame}

% ============================================
% PART 10: CONTRIBUTING TO RUST
% ============================================
\section{Contributing to Rust Itself}

\begin{frame}[fragile]{Rust Compiler Development}
  \begin{lstlisting}
# Clone and build rustc
$ git clone https://github.com/rust-lang/rust.git
$ cd rust
$ ./x.py build

# Run tests
$ ./x.py test

# Build specific component
$ ./x.py build library/std

# Build documentation
$ ./x.py doc
  \end{lstlisting}

  \begin{block}{Key Areas}
    \begin{itemize}
      \item Compiler: Type checking, borrow checking, MIR
      \item Standard library: Core, alloc, std
      \item Cargo: Build system and package manager
      \item Rustdoc: Documentation generator
      \item Clippy: Linter
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{RFC Process}
  \begin{enumerate}
    \item \textbf{Idea}: Discuss on internals.rust-lang.org
    \item \textbf{RFC}: Submit RFC (Request for Comments)
    \item \textbf{Discussion}: Community reviews and suggests changes
    \item \textbf{FCP}: Final Comment Period (10 days)
    \item \textbf{Merge}: RFC accepted, implementation begins
    \item \textbf{Implementation}: Write code, tests, docs
    \item \textbf{Stabilization}: Feature gate removal after testing
  \end{enumerate}

  \vspace{0.5cm}
  \textbf{Example RFCs:}
  \begin{itemize}
    \item RFC 2229: Capture disjoint fields in closures
    \item RFC 2585: FC-solve
    \item RFC 3086: metaevar expr
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Writing Compiler Tests}
  \begin{lstlisting}
// tests/ui/my-feature.rs
fn main() {
    let x: i32 = "hello"; //~ ERROR mismatched types
}

// Run test
$ ./x.py test tests/ui/my-feature.rs

// Update expected output
$ ./x.py test tests/ui --bless
  \end{lstlisting}

  \begin{block}{Test Types}
    \begin{itemize}
      \item \texttt{ui}: Compiler error/warning tests
      \item \texttt{compile-fail}: Tests that should fail compilation
      \item \texttt{run-pass}: Tests that should compile and run
      \item \texttt{incremental}: Incremental compilation tests
    \end{itemize}
  \end{block}
\end{frame}

% ============================================
% PART 11: SUMMARY
% ============================================
\section{Summary and Mastery Path}

\begin{frame}{Key Takeaways}
  \begin{enumerate}
    \item \textbf{Compiler}: Understand MIR and compilation pipeline
    \item \textbf{Proc Macros}: Master complex code generation
    \item \textbf{Allocators}: Implement custom memory management
    \item \textbf{No-std}: Build for embedded and bare metal
    \item \textbf{Wasm}: Deploy Rust to the web
    \item \textbf{Async}: Build custom executors and runtimes
    \item \textbf{Lock-Free}: Implement advanced concurrent data structures
    \item \textbf{Tooling}: Create language tools and IDE support
    \item \textbf{Profiling}: Optimize for maximum performance
    \item \textbf{Contributing}: Give back to the Rust ecosystem
  \end{enumerate}
\end{frame}

\begin{frame}{Mastery Projects}
  \begin{block}{Challenge Yourself}
    \begin{itemize}
      \item Build a custom async runtime
      \item Implement a garbage collector
      \item Create a programming language in Rust
      \item Write a kernel module or OS
      \item Build a database engine
      \item Implement a JIT compiler
      \item Create embedded firmware
      \item Contribute to rustc or cargo
    \end{itemize}
  \end{block}

  \begin{alertblock}{Expert Territory}
    You're now equipped to tackle the most challenging Rust projects!
  \end{alertblock}
\end{frame}

\begin{frame}{Advanced Resources}
  \begin{block}{Deep Dives}
    \begin{itemize}
      \item Rust Compiler Development Guide
      \item Embedded Rust Book
      \item Rust and WebAssembly Book
      \item Lock-Free Programming Papers
      \item "Writing an OS in Rust" blog series
      \item Rustc Dev Guide
    \end{itemize}
  \end{block}

  \begin{block}{Communities}
    \begin{itemize}
      \item \#rustc on Rust Zulip
      \item Embedded WG
      \item Compiler Team meetings
      \item Working Groups (async, wasm, etc.)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{The Journey Continues}
  \begin{center}
    \Large{\textbf{From Beginner to Expert}}

    \vspace{0.5cm}

    \normalsize{
    You've completed the full Rust learning path:
    }

    \vspace{0.3cm}

    \textbf{Beginner} → Fundamentals \\
    \textbf{Intermediate} → Advanced Patterns \\
    \textbf{Advanced} → Expert Techniques

    \vspace{0.5cm}

    \Large{\textbf{Keep Exploring, Keep Building!}}
  \end{center}
\end{frame}

\begin{frame}{Resources}
  \begin{block}{Official Documentation}
    \begin{itemize}
      \item Rustc Dev Guide: \texttt{rustc-dev-guide.rust-lang.org}
      \item Forge: \texttt{forge.rust-lang.org}
      \item Embedded Book: \texttt{docs.rust-embedded.org}
      \item Wasm Book: \texttt{rustwasm.github.io}
    \end{itemize}
  \end{block}

  \begin{block}{Community}
    \begin{itemize}
      \item Zulip: \texttt{rust-lang.zulipchat.com}
      \item Internals Forum: \texttt{internals.rust-lang.org}
      \item GitHub: \texttt{github.com/rust-lang}
      \item This Week in Rust
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
