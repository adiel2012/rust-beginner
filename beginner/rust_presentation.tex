\documentclass{beamer}
\usetheme{Madrid}
\usecolortheme{default}
\usepackage{listings}
\usepackage{xcolor}

% Rust code highlighting
\lstdefinelanguage{Rust}{
  keywords={fn, let, mut, if, else, match, for, while, loop, impl, struct, enum, trait, pub, use, mod, return, break, continue, const, static, type, where, self, Self, async, await, unsafe, dyn, Box, Vec, String, Option, Result, Some, None, Ok, Err},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={i32, i64, u32, u64, f32, f64, bool, char, str, usize},
  ndkeywordstyle=\color{purple}\bfseries,
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  language=Rust,
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  showstringspaces=false
}

\title{Learning Rust: A Beginner's Guide}
\subtitle{From Zero to Rustacean}
\author{Rust Tutorial Series}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Table of Contents}
  \tableofcontents
\end{frame}

% ============================================
% PART 1: GETTING STARTED
% ============================================
\section{Part 1: Getting Started}

\begin{frame}{What is Rust?}
  \begin{block}{Definition}
    Rust is a systems programming language that focuses on:
  \end{block}

  \begin{itemize}
    \item \textbf{Safety}: Memory safety without garbage collection
    \item \textbf{Speed}: Performance comparable to C/C++
    \item \textbf{Concurrency}: Fearless concurrent programming
  \end{itemize}

  \vspace{0.5cm}
  \begin{alertblock}{Fun Fact}
    Created by Mozilla Research, Rust has been voted the "most loved programming language" in Stack Overflow surveys for several years.
  \end{alertblock}
\end{frame}

\begin{frame}{Why Learn Rust?}
  \begin{enumerate}
    \item \textbf{Memory Safety}: No null pointers, no data races
    \item \textbf{Zero-Cost Abstractions}: High-level features without runtime overhead
    \item \textbf{Growing Ecosystem}: Excellent package manager (Cargo) and rich libraries
    \item \textbf{Career Opportunities}: High demand in systems programming, web services, blockchain
    \item \textbf{Great Tooling}: Excellent compiler errors, built-in testing, documentation tools
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Hello, World!}
  \begin{lstlisting}
fn main() {
    println!("Hello, World!");
}
  \end{lstlisting}

  \vspace{0.5cm}
  \begin{block}{Key Elements}
    \begin{itemize}
      \item \texttt{fn main()} - Entry point of every Rust program
      \item \texttt{println!} - A macro (note the \texttt{!})
      \item Statements end with semicolons \texttt{;}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Installing Rust}
  \begin{block}{Installation}
    Visit \texttt{rustup.rs} and run:
  \end{block}

  \begin{verbatim}
    curl --proto '=https' --tlsv1.2 -sSf
      https://sh.rustup.rs | sh
  \end{verbatim}

  \vspace{0.3cm}
  \begin{block}{Verify Installation}
    \begin{verbatim}
    rustc --version
    cargo --version
    \end{verbatim}
  \end{block}
\end{frame}

% ============================================
% PART 2: BASIC SYNTAX
% ============================================
\section{Basic Syntax and Concepts}

\begin{frame}[fragile]{Variables and Mutability}
  \begin{block}{Immutable by Default}
    \begin{lstlisting}
let x = 5;
// x = 6;  // ERROR! Cannot assign twice to immutable
    \end{lstlisting}
  \end{block}

  \begin{block}{Mutable Variables}
    \begin{lstlisting}
let mut y = 5;
y = 6;  // OK!
println!("y = {}", y);
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Data Types}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \textbf{Scalar Types:}
      \begin{lstlisting}
// Integers
let a: i32 = 42;
let b: u64 = 100;

// Floats
let c: f64 = 3.14;

// Boolean
let d: bool = true;

// Character
let e: char = 'R';
      \end{lstlisting}
    \end{column}

    \begin{column}{0.5\textwidth}
      \textbf{Compound Types:}
      \begin{lstlisting}
// Tuple
let tup = (500, 6.4, 'x');
let (x, y, z) = tup;

// Array
let arr = [1, 2, 3, 4, 5];
let first = arr[0];
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Functions}
  \begin{lstlisting}
fn add(a: i32, b: i32) -> i32 {
    a + b  // Expression (no semicolon)
}

fn subtract(a: i32, b: i32) -> i32 {
    return a - b;  // Explicit return
}

fn main() {
    println!("5 + 3 = {}", add(5, 3));
    println!("10 - 4 = {}", subtract(10, 4));
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Control Flow: if/else}
  \begin{lstlisting}
fn main() {
    let number = 7;

    if number < 5 {
        println!("Less than 5");
    } else if number < 10 {
        println!("Between 5 and 10");
    } else {
        println!("10 or greater");
    }

    // if is an expression
    let x = if number < 5 { 1 } else { 2 };
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Loops}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \textbf{loop:}
      \begin{lstlisting}
let mut count = 0;
loop {
    count += 1;
    if count == 10 {
        break;
    }
}
      \end{lstlisting}

      \vspace{0.3cm}
      \textbf{while:}
      \begin{lstlisting}
let mut n = 3;
while n != 0 {
    println!("{}!", n);
    n -= 1;
}
      \end{lstlisting}
    \end{column}

    \begin{column}{0.5\textwidth}
      \textbf{for:}
      \begin{lstlisting}
let arr = [10, 20, 30];
for element in arr.iter() {
    println!("{}", element);
}

// Range
for n in 1..4 {
    println!("{}!", n);
}
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

% ============================================
% PART 3: OWNERSHIP
% ============================================
\section{Core Concepts: Ownership}

\begin{frame}{Ownership Rules}
  \begin{block}{The Three Rules of Ownership}
    \begin{enumerate}
      \item Each value in Rust has a variable that's called its \textbf{owner}
      \item There can only be \textbf{one owner} at a time
      \item When the owner goes out of scope, the value will be \textbf{dropped}
    \end{enumerate}
  \end{block}

  \vspace{0.5cm}
  \begin{alertblock}{Why Ownership?}
    Ownership enables memory safety without garbage collection!
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Move Semantics}
  \begin{lstlisting}
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 is moved to s2

    // println!("{}", s1);  // ERROR! s1 no longer valid
    println!("{}", s2);     // OK
}
  \end{lstlisting}

  \begin{block}{Key Point}
    When we assign \texttt{s1} to \texttt{s2}, the String data is \textbf{moved}, not copied. \texttt{s1} is no longer valid!
  \end{block}
\end{frame}

\begin{frame}[fragile]{Clone and Copy}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \textbf{Clone (Deep Copy):}
      \begin{lstlisting}
let s1 = String::from("hello");
let s2 = s1.clone();

// Both valid
println!("{}", s1);
println!("{}", s2);
      \end{lstlisting}
    \end{column}

    \begin{column}{0.5\textwidth}
      \textbf{Copy (Stack Only):}
      \begin{lstlisting}
let x = 5;
let y = x;  // Copy, not move

// Both valid
println!("{}", x);
println!("{}", y);
      \end{lstlisting}
    \end{column}
  \end{columns}

  \vspace{0.3cm}
  \begin{block}{Copy Types}
    Simple types on the stack: integers, floats, booleans, characters
  \end{block}
\end{frame}

% ============================================
% PART 4: REFERENCES AND BORROWING
% ============================================
\section{References and Borrowing}

\begin{frame}[fragile]{References}
  \begin{lstlisting}
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);

    println!("Length of '{}' is {}", s1, len);
    // s1 is still valid!
}

fn calculate_length(s: &String) -> usize {
    s.len()
}  // s goes out of scope but doesn't drop the String
  \end{lstlisting}

  \begin{block}{Borrowing}
    Creating a reference is called \textbf{borrowing}. References don't take ownership.
  \end{block}
\end{frame}

\begin{frame}{The Borrowing Rules}
  \begin{block}{Rules Enforced at Compile Time}
    At any given time, you can have \textbf{either}:
    \begin{itemize}
      \item One mutable reference, \textbf{OR}
      \item Any number of immutable references
    \end{itemize}
  \end{block}

  \vspace{0.5cm}
  \begin{alertblock}{Prevents Data Races!}
    Rust prevents data races at compile time through these rules.
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Mutable References}
  \begin{lstlisting}
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
    println!("{}", s);
}

fn change(s: &mut String) {
    s.push_str(", world");
}
  \end{lstlisting}

  \begin{alertblock}{Restriction}
    You can only have ONE mutable reference to a value in a scope!
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Slices}
  \begin{lstlisting}
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];   // or &s[..5]
    let world = &s[6..11];  // or &s[6..]

    println!("{} {}", hello, world);
}
  \end{lstlisting}

  \begin{block}{String Slice Type: \texttt{\&str}}
    Slices reference a contiguous sequence without taking ownership.
  \end{block}
\end{frame}

% ============================================
% PART 5: STRUCTS AND ENUMS
% ============================================
\section{Structs and Enums}

\begin{frame}[fragile]{Defining Structs}
  \begin{lstlisting}
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: String::from("user@example.com"),
        username: String::from("user123"),
        active: true,
        sign_in_count: 1,
    };

    println!("User: {}", user1.username);
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Methods}
  \begin{lstlisting}
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Enums}
  \begin{lstlisting}
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let home = IpAddr::V4(127, 0, 0, 1);
let msg = Message::Write(String::from("hello"));
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Pattern Matching}
  \begin{lstlisting}
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Option Enum}
  \begin{lstlisting}
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Some(result) => println!("Result: {}", result),
        None => println!("Cannot divide by zero"),
    }
}
  \end{lstlisting}

  \begin{block}{No Null in Rust!}
    \texttt{Option<T>} replaces null values safely.
  \end{block}
\end{frame}

% ============================================
% PART 6: COLLECTIONS
% ============================================
\section{Collections}

\begin{frame}[fragile]{Vectors}
  \begin{lstlisting}
fn main() {
    // Creating vectors
    let v1: Vec<i32> = Vec::new();
    let v2 = vec![1, 2, 3];

    // Adding elements
    let mut v3 = Vec::new();
    v3.push(5);
    v3.push(6);

    // Accessing elements
    let third = &v3[2];
    match v3.get(2) {
        Some(third) => println!("Third: {}", third),
        None => println!("No third element"),
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Hash Maps}
  \begin{lstlisting}
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    // Getting values
    let team = String::from("Blue");
    let score = scores.get(&team);

    // Iterating
    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 7: ERROR HANDLING
% ============================================
\section{Error Handling}

\begin{frame}[fragile]{Result Type}
  \begin{lstlisting}
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            println!("Error: {:?}", error);
            return;
        }
    };
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The ? Operator}
  \begin{lstlisting}
use std::fs::File;
use std::io::{self, Read};

fn read_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

// Even more concise
fn read_file_short() -> Result<String, io::Error> {
    std::fs::read_to_string("hello.txt")
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 8: GENERICS AND TRAITS
% ============================================
\section{Generics and Traits}

\begin{frame}[fragile]{Generic Functions}
  \begin{lstlisting}
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    println!("Largest: {}", largest(&numbers));
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Traits}
  \begin{lstlisting}
trait Summary {
    fn summarize(&self) -> String;
}

struct Article {
    headline: String,
    content: String,
}

impl Summary for Article {
    fn summarize(&self) -> String {
        format!("{}", self.headline)
    }
}
  \end{lstlisting}
\end{frame}

% ============================================
% PART 9: CONCURRENCY
% ============================================
\section{Fearless Concurrency}

\begin{frame}[fragile]{Threads}
  \begin{lstlisting}
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("Thread: {}", i);
        }
    });

    for i in 1..5 {
        println!("Main: {}", i);
    }

    handle.join().unwrap();
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Channels}
  \begin{lstlisting}
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send(String::from("hi")).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Shared State with Mutex}
  \begin{lstlisting}
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            *counter.lock().unwrap() += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
  \end{lstlisting}
\end{frame}

% ============================================
% SUMMARY
% ============================================
\section{Summary and Next Steps}

\begin{frame}{What We've Learned}
  \begin{itemize}
    \item \textbf{Basics}: Variables, types, functions, control flow
    \item \textbf{Ownership}: Rust's unique memory management system
    \item \textbf{Borrowing}: References and the borrow checker
    \item \textbf{Structs \& Enums}: Custom data types
    \item \textbf{Collections}: Vectors, strings, hash maps
    \item \textbf{Error Handling}: Result and Option types
    \item \textbf{Generics \& Traits}: Code reuse and polymorphism
    \item \textbf{Concurrency}: Fearless concurrent programming
  \end{itemize}
\end{frame}

\begin{frame}{Next Steps}
  \begin{enumerate}
    \item \textbf{Practice Daily}: Write Rust code every day
    \item \textbf{Build Projects}: Apply what you've learned
    \item \textbf{Read Code}: Study well-written Rust projects
    \item \textbf{Join Community}: Rust forum, Discord, Reddit
    \item \textbf{Advanced Topics}: Macros, async/await, unsafe Rust
    \item \textbf{Contribute}: Open source Rust projects
  \end{enumerate}

  \vspace{0.5cm}
  \begin{center}
    \Large{\textbf{Happy Coding, Rustacean!}}
  \end{center}
\end{frame}

\begin{frame}{Resources}
  \begin{block}{Official Resources}
    \begin{itemize}
      \item The Rust Book: \texttt{doc.rust-lang.org/book/}
      \item Rust by Example: \texttt{doc.rust-lang.org/rust-by-example/}
      \item Rustlings: Interactive exercises
    \end{itemize}
  \end{block}

  \begin{block}{Community}
    \begin{itemize}
      \item Forum: \texttt{users.rust-lang.org}
      \item Reddit: \texttt{r/rust}
      \item Discord: Rust Community Server
    \end{itemize}
  \end{block}

  \begin{block}{This Tutorial}
    \begin{itemize}
      \item GitHub: \texttt{github.com/adiel2012/rust-beginner}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
